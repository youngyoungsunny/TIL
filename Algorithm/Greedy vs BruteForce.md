## 알고리즘의 큰 개요

1. 완전탐색 ( 브루트포스 / BF )

2. BackTracking ( 백트래킹 )

3. 동적 계획법 

4. 그리디 알고리즘

5. DFS/ BFS 

6. 기타 ( 분할정복, 이분탐색, 수학, 자료구조활용 알고리즘 등등..)

---------------------------------------------------------

### 완전탐색 ( 브루트포스 / BF )
- 문자그대로 완전히 탐색하는 알고리즘이다. "무식한 알고리즘"이라고 생각해도 된다. 
이 알고리즘의 핵심은 **"모든 경우의 수의 대입"** !

- 통칭 Brute Force를 줄여 BF라고 부름. 브루트 포스 뜻은 무자비한 힘, 그니까 압도적인 계산량으로 밀고 들어가서 계산한다는 뜻이다. 

- 말만 무식한 알고리즘이지, 막상 의외로 많은 문제의 해답이 BF인 경우가 많다. 
- 그래도, 어느정도 최적화를 해야 BF로 풀리는 경우도 있으니, 최대한 계산량을 줄이는 방법을 생각해야 한다.

- 모든 경우의 수를 대입해서 계산을 하려고 컴퓨터가 생겼고, 알고리즘 기초단계에서 BF는 굉장히 많이 쓰이고 기준이 되는 알고리즘이다. 맨처음엔 BF를 기준으로 계산량을 가늠해볼때가 많다.

- **"탐색 : 모든 경우의 수를 대입해보는 알고리즘"**

-----------------------------------------------
### 2. 그리디 알고리즘 (Greedy Algorithm , 탐욕적 알고리즘)

- 탐욕스럽게 당장 눈앞에 최적해를 쫓다보면 ~> 전체의 최적해가 나오는 알고리즘
- 대표적으로 동전 문제 https://www.acmicpc.net/problem/11047


11047번: 동전 0
문제 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. 입력 첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000) 둘째 줄부터 N개의 줄에 동전의 가치 A i 가 오름차순으로 주어진다. (1 ≤ A i ≤ 1,000,000, A 1 = 1, i ≥ 2인 경우에 A i 는 A i-1 의 배수) 출력 첫째 줄에 K원을 만드는데 필요한 동전 개...

www.acmicpc.net

- 그리디 알고리즘 : 당장 눈앞의 최적해를 좇으면 전체의 최적해가 나오는  알고리즘

그리디 알고리즘이란, 최적해를 구하는 데에 사용되는 근사적인 방법으로, 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘이다. lost_n의 원소 하나하나를 보면서, reserve_n에 가능한 대체재가 존재하면 바로 가져다 쓰는 방법을 이용했다.

해당 풀이의 경우 for문으로 O(n), remove에서 O(n)으로 시간 복잡도가 O(n^2)에 달한다. 효율적이진 않지만 ,, 다른 방법을 조금 더 생각해보아야겠다.



출처: https://kdgt-programmer.tistory.com/3 [유치원생 개발자 블로그]

-------------------------------------
### 3. 백트래킹 : 뒤로 돌아가서 다른 시도를 해보는 알고리즘

- 얘는 뒤에 DFS/BFS에서 설명을 해야할 것 같아요. 뒤로가면서 다른 시도할 여지가 있는지 탐색 후, 다른 시도가 있으면 해보는 개념입니다. 밑에 다시 설명

-----------------------------------------
### 4. 동적 계획법(Dynamic Programming, DP,동적 프로그래밍)

- 쉽게 이야기해서, 중간 중간에 메모를 적어놓고 그 메모로 최적해를 구하는 기법이다.
- 중간 중간에 메모를 적는 것을 Memoization(메모이제이션)이라고도 하는데, 많은 알고리즘 입문자를 좌절시킨다고 한다. 처음 접하면 많이 어렵다.
- 처음 접할때는 한 문제정도는 몇시간 땅에 헤딩해보고 답을 접하면 이걸 사람이 어떻게 생각해 라는 소리가 절로 나올 겁니다. 그리고 유형에 익숙해지면 눈에 보입니다. 

- 동적계획법 : 최적해를 구하기위해  메모를 하는 알고리즘

-----------------------------------------
### 5. DFS/ BFS 
- DFS = Depth First Search 깊이 우선 탐색

- BFS = Breadth First Search 너비 우선 탐색

DFS/BFS/BackTracking 이 3가지의 차이를 알려드릴게요.

빨간색에서 시작해서 파란색을 찾아야한다고 할때, DFS/BFS?BackTracking 세가지 동작방법을 보여드릴게요. (참고: https://m.blog.naver.com/aver2933/221912056658 )


- DFS는 재귀함수로 구현을 하고
- BFS는 큐로 구현을 하고
- BackTracking은 재귀함수로 구현한다.


보통 함수의 원형은,

void DFS(int depth){
      if(조건문) ~실행
      else DFS(depth+1)

------

queue<E> q
q.push(첫번째꺼)
while(!q.isEmpty()){
      if( 조건문 ) break;
      else q.push(다른거)
}

-----

void backTracking(int depth){
       if(조건문) ~실행
       else {
            뭔가를 함
            backTracking(depth+1) 
            뭔가를 원래대로 다시 되돌림
       }
}
이렇게 됩니다.

-----------------------------------------------------

### 5. 기타

- 기타로는 , 이분탐색, 분할정복, 기타 수학 알고리즘, 정렬이나 각종 자료구조 이용하는 알고리즘들이 있다. 기타라고 써놓았지만, 중요하지 않은 알고리즘은 아닙니다. 이중에 특히 이분탐색,
정렬은 잘 알아놓아야한다.

  -------------------------------------------------
  
  ### 6. 기초 이후에 배울 알고리즘들

1. 그래프
2. 트리
3. 많이 어려운 동적계획법
4. 기타
